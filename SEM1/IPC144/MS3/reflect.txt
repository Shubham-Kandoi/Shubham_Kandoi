/*/////////////////////////////////////////////////////////////////////////
Full Name  : Shubham Dharmendrabhai Kandoi
Student ID#: 144838232
Email      : sdkandoi@myseneca.ca
Section    : ZBB

Authenticity Declaration:
I declare this submission is the result of my own work and has not been
shared with any other student or 3rd party content provider. This submitted
piece of work is entirely of my own creation.
/////////////////////////////////////////////////////////////////////////*/

A1.
The string library in C provides a wide range of functions for various string operations, such as copying, concatenating, comparing, searching, and manipulating strings, reducing the need to implement these functionalities yourself, which can save developer time and efforts through this library functions.

MS1:
void displayFormattedPhone(const char* phoneNumber) {
   
    int len = 0, i;

    while (phoneNumber != NULL && phoneNumber[len] && isdigit(phoneNumber[len])) {
    
        len++;
    
    }
    
    if (len == 10) {
    
        i = 0;
        
        printf("(");
        
        while (i < 3) {
          
            printf("%c", phoneNumber[i]);
            
            i++;
        
        }
        
        printf(")");
        
        while (i < 6) {
        
            printf("%c", phoneNumber[i]);
            
            i++;
        
        }
        
        printf("-");
       
        while (i < 10) {
           
            printf("%c", phoneNumber[i]);
            
            i++;
        
        }
    }
    
    else {
        
        printf("(___)___-____");
   
    }
    
    if (phoneNumber != 0) {
    
        for (i = 0; phoneNumber[i] != '\0'; i++)
        
            len++;
    
    }

}

Code Snippet from MS2:
void displayFormattedPhone(const char* phoneNumber)
{
	int i;

	if (phone == NULL || strlen(phoneNumber) != 10)
	{
		printf("(___)___-____");
		return;
	}

	for (i = 0; i < 10; i++) {
		if (phoneNumber[i] < '0' || phoneNumber[i] > '9')
		{
			printf("(___)___-____");
			return;
		}
	}

	printf("(%c%c%c)%c%c%c-%c%c%c%c", phoneNumber[0], phoneNumber[1], phoneNumber[2], phoneNumber[3], phoneNumber[4], phoneNumber[5], phoneNumber[6], phoneNumber[7], phoneNumber[8], phoneNumber[9]);
}

-> "void displayFormattedPhone(const char* phoneNumber)" function purpose is to validate and formatting a given phone number.
-> In MS1 for length validation I have used a manual while loop to validate the length and digit characters while in MS2 I have used string library function "strlen" to validate length and also a dedicated for loop.
->By using string library function in MS2 makes my code more concise, clear and a direct approach to input validation and phone number formatting by utilizing string library functions and simpler loops, while MS1 code snippetinvolves more manual processing and redundancy.

A2.
Two primary string copy functions in C are :
1. strcpy
2.strncpy

-> Strncpy() is preferred over strcpy() because 

1.strcpy:
->Can lead to the risk of Buffer Overflow
->Security vulnerabilities and potential causing memory corruption.
->Copy entire contents of the source string to the destination string untill the null-terminator.

2.strncpy:
-> Better control and safer handling of data
-> Can help prevent buffer overflow by allowing you to specify the maximum number of characters to copy.

-> Example
// string copy using strcpy
strcpy(phone->number, inputNumber)

//Updated string copying using strncpy
strncpy(phone->number, inputNumber, PHONE_LEN)

->In function I have replaced strcpy(phone->number, inputNumber) to strncpy(phone->number, inputNumber, PHONE_LEN). By using strncpy, we limit the number of characters copied from inmputNumber to phone->number  to the size of the phone->number buffer (PHONE_LEN).This helps prevent potential buffer overflows that could occur if inputNumber is longer than the allocated space for phone->number.

A3.

1.To keep the list of appointments in the correct order I made a function called void sort(struct Appointment appoints[], int max) 

2. The sort function takes an array Appointment structures (appoints) and as an argument i took (max) as the maximum number of appointments.

3.I made a nested loop which convert the date and time values of each appointment into total minutes. This conversion is done by calculating the number of minutes from the year, month, day, hour, and minute values of each appointment.

// Storing all the date and time values in minutes for comparison
for (i = 0; i < max; i++) {
    appoints[i].time.min = (appoints[i].date.year * 12 * 30 * 24 * 60) + (appoints[i].date.month * 30 * 24 * 60) + (appoints[i].date.day * 24 * 60) + (appoints[i].time.hour * 60) + appoints[i].time.min;
}

4.Now, after converting date and time values to total minutes, a bubble sort algorithm is used to swap rows and columns accordingly.

// Using bubble sort to compare minutes and then swap the structs
for (i = max - 1; i > 0; i--)
{
    for (j = 0; j < i; j++)
    {
        if (appoints[j].time.min > appoints[j + 1].time.min)
        {
            temp = appoints[j];
            appoints[j] = appoints[j + 1];
            appoints[j + 1] = temp;
        }
    }
}

5. Finally, the minutes should be converted to back into days and hours by subtracting the calculated total minutes from the year, month, day, and hour values.

 // Converting total minutes back to minutes
 for (i = 0; i < max; i++) {
     appoints[i].time.min = appoints[i].time.min - (appoints[i].date.year * 12 * 30 * 24 * 60) - (appoints[i].date.month * 30 * 24 * 60) - (appoints[i].date.day * 24 * 60) - (appoints[i].time.hour * 60);
 }

-> By using this approach, the sort function ensures that the list of appointments is always sorted in ascending order based on the date and time.

-> The sort() function currently converts the date and time values to minutes for comparison. This can lead to issues with overflow for appointments which could cause a problem. A better approach would be to compare the date and time values directly using a custom comparison function.
