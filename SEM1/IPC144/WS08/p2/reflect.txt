///////////////////////////////////////////////////////////////////////////
                               Reflection
                             Workshop - #8
Full Name  : Shubham Dharmendrabhai Kandoi
Student ID#: 144838232

Authenticity Declaration:
I declare this submission is the result of my own work and has not been
shared with any other student or 3rd party content provider. This submitted
piece of work is entirely of my own creation.
///////////////////////////////////////////////////////////////////////////

A1. The two ways to return a value are :
1.The function returns the result of the conversion directly. This means that the value is returned as the function's return value, and the caller can access it directly after calling the function.
->For example:
// Function to convert pounds to kilograms and return the result directly
double convertLbsToKg(const double lbs);
2. The function also accepts a pointer to a variable as a parameter, which allows it to return a value indirectly, the result by storing the value in the memory location pointed by the pointer. So, this function will accept a pointer to a variable where it would store its result. 
-> This way also enables a function to modify the value of the variable. 
-> For example :
// Function to convert pounds to kilograms and store the result in the provided pointer
void convertLbsToKgPtr(const double lbs, double* kg);

A2.
-> getCatFoodInfo(const int sequence_Info):
- It is highly cohesive because this function performs a specific well-defined task related to handling the cat Food data such as, this function is responsible for collecting information about a cat food product.
 - It is loosely coupled because it only interacts with the user input system and does not rely on other functions within the program.

-> calculateReportData(struct CatFoodInfo cfi):
-It is highly cohesive as this function calculates derived data points for the analysis report based on the provided cat food data, which means the function focuses only on the processing cat food data and genrates related analysis metrics.
-It is loosely coupled because it operates on the 'CatFoodInfo' struct passed to it and does not directly interact with the user input or display function.

-> displayFinalAnalysis(const struct CatFoodInfo cfi) :
- This function is highly cohesive because it displays the final analysis results, including the SKU and price of the cat food option.It concentrates solely on presenting the final analysis to the user which makes this function higjly cohesive.
-It is loosely coupled because it only relies ont the CatFoodInfo struct to diaplay the SKU and price of the chosen cat Food product. It does not directly interact with the other parts of the program logic or data processing.

A3.
1.The codebase becomes more organised and readable if we place function prototypes in header files and function definitions in source code files. So, coders can easily navigate, understand the interfaces and locate the implemantation details.
->For example : In the workshop, the separation of interface and implementation makes it easier to identify which functions are available for use and where to find their implementations.

2. Header files facilates the code reuseability by providing a standerdized interface which can be included in multiple source files. Also, it promotes the portability because we can use same header file across different projects.
->For example:  The header file w8p2.h can be reused in other programs that require similar functionality related to cat food analysis. So, from this we can reuse the code and reduce the duplication.

3. During the development process, header files are enable to compile-time check of funtion calls, which reduce the errors anf inconsistencies of the code. 
->For example: If a function prototype in the header file does not match its corresponding implementation in the source code file, the compiler will generate an error and alert the coder about this issues.

4. Header files hide the inner workings or code of functions, which allows users to interact with them without needing to know how they are implemented. This sepration ensures that if any changes happen or made to the function implementation won't afftect how users interact with it.
->For example : The header files of this workshop(w8p1.h and w8p2.h) only reveals the function prototypes, which keeps the implementation details hidden. 

